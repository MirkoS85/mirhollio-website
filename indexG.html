<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MirSFlr - Flare Network Live Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; color: #333; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #1a73e8; }
        .section { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .counter { font-size: 2em; font-weight: bold; color: #1a73e8; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 10px; text-align: left; border-bottom: 1px solid #ddd; }
        th { background-color: #f8f9fa; }
        .loading { text-align: center; color: #666; }
        .error { color: #d93025; text-align: center; }
        canvas { max-width: 100%; height: 300px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script> <!-- Za stake chart -->
</head>
<body>
    <div class="container">
        <h1>ðŸ”¥ MirSFlr - Flare Network Live Podatki</h1>
        
        <!-- FLR Price -->
        <div class="section">
            <h2>FLR Token Price (EUR)</h2>
            <div id="flr-price" class="counter loading">Nalagam...</div>
        </div>
        
        <!-- Transactions -->
        <div class="section">
            <h2>Transakcije (24h)</h2>
            <div id="tx-counter" class="counter loading">Nalagam...</div>
            <table id="tx-table">
                <thead><tr><th>Hash</th><th>Od</th><th>Do</th><th>Vrednost</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        
        <!-- Active Validators -->
        <div class="section">
            <h2>Aktivni Validatorji</h2>
            <div id="validators-counter" class="counter loading">Nalagam...</div>
            <table id="validators-table">
                <thead><tr><th>Node ID</th><th>Stake</th><th>Delegated</th><th>Status</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        
        <!-- Stake / Delegations -->
        <div class="section">
            <h2>Stake & Delegations</h2>
            <div id="stake-info" class="loading">Nalagam...</div>
            <canvas id="stake-chart"></canvas>
        </div>
        
        <!-- Network Activity -->
        <div class="section">
            <h2>Network Activity (zadnjih 10 dni)</h2>
            <div id="activity-info" class="loading">Nalagam...</div>
        </div>
    </div>

    <script>
        const BLOCKSCOUT_BASE = 'https://flare-explorer.flare.network/api/v2';
        const FLARE_RPC = 'https://flare-api.flare.network/ext/bc/P'; // P-chain RPC
        const COINGECKO_PROXY = 'https://api.allorigins.win/raw?url='; // CORS proxy
        const COINGECKO_URL = 'https://api.coingecko.com/api/v3/simple/price?ids=flare&vs_currencies=eur';
        
        let stakeChart; // Za chart
        
        // Fetch REST (Blockscout)
        async function fetchRest(endpoint) {
            try {
                const response = await fetch(`${BLOCKSCOUT_BASE}${endpoint}`);
                if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('Blockscout Error:', error);
                return { error: error.message };
            }
        }
        
        // Fetch RPC (POST za P-chain)
        async function fetchRpc(method, params = {}) {
            try {
                const response = await fetch(FLARE_RPC, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: method,
                        params: [params]
                    })
                });
                if (!response.ok) throw new Error(`HTTP error: ${response.status}`);
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                return data.result;
            } catch (error) {
                console.error('RPC Error:', error);
                return { error: error.message };
            }
        }
        
        // OsveÅ¾i vse
        async function updateDashboard() {
            // FLR Price
            try {
                const priceResponse = await fetch(COINGECKO_PROXY + encodeURIComponent(COINGECKO_URL));
                if (!priceResponse.ok) throw new Error('Proxy/CoinGecko error');
                const priceData = await priceResponse.json();
                document.getElementById('flr-price').textContent = `${priceData.flare.eur.toFixed(4)} â‚¬`;
                document.getElementById('flr-price').classList.remove('error', 'loading');
            } catch (error) {
                document.getElementById('flr-price').textContent = `Napaka: ${error.message}`;
                document.getElementById('flr-price').classList.add('error');
            }
            
            // Transactions
            const txData = await fetchRest('/transactions?limit=10');
            const statsData = await fetchRest('/stats');
            const txTable = document.querySelector('#tx-table tbody');
            const txCounter = document.getElementById('tx-counter');
            if (txData.error || statsData.error) {
                txCounter.textContent = `Napaka: ${txData.error || statsData.error}`;
                txCounter.classList.add('error');
            } else {
                txCounter.textContent = `${statsData.transactions_today || 'N/A'} (24h)`;
                txCounter.classList.remove('error', 'loading');
                txTable.innerHTML = (txData.items || []).map(tx => `
                    <tr>
                        <td>${tx.hash.slice(0,10)}...</td>
                        <td>${tx.from.hash.slice(0,10)}...</td>
                        <td>${tx.to ? tx.to.hash.slice(0,10)+'...' : 'Contract'}</td>
                        <td>${tx.value ? (BigInt(tx.value) / BigInt(1e18n)).toString() + ' FLR' : '0'}</td>
                    </tr>
                `).join('');
            }
            
            // Active Validators (RPC: platform.getCurrentValidators)
            const validatorsData = await fetchRpc('platform.getCurrentValidators', { subnetID: null });
            const valTable = document.querySelector('#validators-table tbody');
            const valCounter = document.getElementById('validators-counter');
            if (validatorsData.error) {
                valCounter.textContent = `Napaka: ${validatorsData.error}`;
                valCounter.classList.add('error');
            } else {
                const validators = validatorsData.validators || [];
                valCounter.textContent = `Aktivnih: ${validators.length}`;
                valCounter.classList.remove('error', 'loading');
                valTable.innerHTML = validators.slice(0,20).map(val => `
                    <tr>
                        <td>${val.nodeID.slice(0,10)}...</td>
                        <td>${(BigInt(val.stakeAmount) / BigInt(1e18n)).toString()} FLR</td>
                        <td>${(BigInt(val.delegatedAmount) / BigInt(1e18n)).toString()} FLR</td>
                        <td>Aktiven</td>
                    </tr>
                `).join('');
            }
            
            // Stake / Delegations (RPC: platform.getTotalStake + validators za porazdelitev)
            const totalStakeData = await fetchRpc('platform.getTotalStake');
            const stakeDiv = document.getElementById('stake-info');
            if (totalStakeData.error) {
                stakeDiv.textContent = `Napaka: ${totalStakeData.error}`;
                stakeDiv.classList.add('error');
            } else {
                const totalStake = BigInt(totalStakeData.stakeAmount) / BigInt(1e18n);
                const totalDelegated = (validatorsData.validators || []).reduce((sum, val) => sum + BigInt(val.delegatedAmount), 0n) / BigInt(1e18n);
                stakeDiv.innerHTML = `
                    <p>Total Stake: ${totalStake.toString()} FLR</p>
                    <p>Total Delegations: ${totalDelegated.toString()} FLR</p>
                `;
                stakeDiv.classList.remove('loading', 'error');
                
                // Chart porazdelitve (top 5 validators po total stake)
                const sortedValidators = (validatorsData.validators || []).sort((a, b) => 
                    (BigInt(b.stakeAmount) + BigInt(b.delegatedAmount)) - (BigInt(a.stakeAmount) + BigInt(a.delegatedAmount))
                ).slice(0, 5);
                const chartCtx = document.getElementById('stake-chart').getContext('2d');
                if (stakeChart) stakeChart.destroy();
                stakeChart = new Chart(chartCtx, {
                    type: 'pie',
                    data: {
                        labels: sortedValidators.map(v => v.nodeID.slice(0,6)+'...'),
                        datasets: [{
                            data: sortedValidators.map(v => (BigInt(v.stakeAmount) + BigInt(v.delegatedAmount)) / BigInt(1e18n)),
                            backgroundColor: ['#1a73e8', '#0f9d58', '#db4437', '#f4b400', '#ab47bc']
                        }]
                    },
                    options: { responsive: true, plugins: { legend: { position: 'top' } } }
                });
            }
            
            // Network Activity (zadnjih 10 dni: approx z blocks)
            const blocksData = await fetchRest('/blocks?limit=100');
            const activityDiv = document.getElementById('activity-info');
            if (blocksData.error) {
                activityDiv.textContent = `Napaka: ${blocksData.error}`;
                activityDiv.classList.add('error');
            } else {
                const tenDaysAgo = Date.now() - 10 * 24 * 60 * 60 * 1000;
                const recentBlocks = (blocksData.items || []).filter(block => new Date(block.timestamp).getTime() > tenDaysAgo);
                // Dnevni count (group by day)
                const dailyCounts = recentBlocks.reduce((acc, block) => {
                    const day = new Date(block.timestamp).toLocaleDateString();
                    acc[day] = (acc[day] || 0) + 1;
                    return acc;
                }, {});
                activityDiv.innerHTML = Object.entries(dailyCounts).map(([day, count]) => `<p>${day}: ${count} blokov</p>`).join('');
                activityDiv.classList.remove('loading');
            }
        }
        
        // Inicialno in osveÅ¾evanje
        updateDashboard();
        setInterval(updateDashboard, 30000);
    </script>
</body>
</html>