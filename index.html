<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MirSFlr - Flare Network Live Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; color: #333; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #1a73e8; }
        .section { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .counter { font-size: 2em; font-weight: bold; color: #1a73e8; text-align: center; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; font-size: 0.9em; }
        th { background-color: #f8f9fa; }
        .loading { text-align: center; color: #666; }
        .error { color: #d93025; text-align: center; }
        details { margin-top: 10px; }
        summary { cursor: pointer; font-weight: bold; color: #1a73e8; }
        .activity-text { font-size: 0.9em; color: #666; margin-bottom: 10px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üî• MirSFlr - Flare Network Live Podatki</h1>
        
        <!-- FLR Price -->
        <div class="section">
            <h2>FLR Token Price (EUR)</h2>
            <div id="flr-price" class="counter loading">Nalagam...</div>
        </div>
        
        <!-- Transactions -->
        <div class="section">
            <h2>Transakcije (24h)</h2>
            <div id="tx-counter" class="counter loading">Nalagam...</div>
            <details id="tx-details">
                <summary>Raz≈°iri zadnjih 10 transakcij</summary>
                <table id="tx-table">
                    <thead><tr><th>Hash</th><th>Od</th><th>Do</th><th>Vrednost</th></tr></thead>
                    <tbody></tbody>
                </table>
            </details>
        </div>
        
        <!-- Active Validators -->
        <div class="section">
            <h2>Aktivni Validatorji</h2>
            <div id="validators-counter" class="counter loading">Nalagam...</div>
            <table id="validators-table">
                <thead><tr><th>Node ID</th><th>Stake</th><th>Delegated</th><th>Status</th></tr></thead>
                <tbody></tbody>
            </table>
        </div>
        
        <!-- Stake / Delegations -->
        <div class="section">
            <h2>Stake & Delegations</h2>
            <div id="stake-info" class="loading">Nalagam...</div>
        </div>
        
        <!-- Network Activity -->
        <div class="section">
            <h2>Network Activity (zadnjih 10 dni)</h2>
            <div class="activity-text">To je pribli≈æek aktivnosti preko ≈°tevila novih blokov na dan ‚Äì ka≈æe network health (veƒç blokov = veƒçja aktivnost). Za natanƒçne nove validatorje/delegatorje: ~2 novi validatorji, brez novih delegatorjev (vir: Flare Builders Tracker, sept 2025).</div>
            <div id="activity-info" class="loading">Nalagam...</div>
        </div>
    </div>

    <script>
        const BLOCKSCOUT_BASE = 'https://flare-explorer.flare.network/api/v2';
        const FLARE_RPC = 'https://flare-api.flare.network/ext/bc/P';
        const COINCAP_URL = 'https://api.coincap.io/v2/assets/flare'; // Free alternative za price
        const USD_TO_EUR = 0.92; // Pribli≈æen teƒçaj (posodobi po potrebi)
        const ATTO = BigInt("1000000000000000000");
        
        // Fetch REST
        async function fetchRest(endpoint) {
            try {
                const response = await fetch(`${BLOCKSCOUT_BASE}${endpoint}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('Blockscout Error:', error);
                return { error: error.message };
            }
        }
        
        // Fetch RPC - params: [] za vse
        async function fetchRpc(method) {
            try {
                const response = await fetch(FLARE_RPC, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: method,
                        params: []  // Prazno array za vse validatorje/stake
                    })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                return data.result;
            } catch (error) {
                console.error('RPC Error:', error);
                return { error: error.message };
            }
        }
        
        // Osve≈æi
        async function updateDashboard() {
            // FLR Price (CoinCap)
            const priceDiv = document.getElementById('flr-price');
            try {
                const priceResponse = await fetch(COINCAP_URL);
                if (!priceResponse.ok) throw new Error('CoinCap error');
                const priceData = await priceResponse.json();
                const usdPrice = parseFloat(priceData.data.priceUsd);
                const eurPrice = (usdPrice * USD_TO_EUR).toFixed(4);
                priceDiv.textContent = `${eurPrice} ‚Ç¨`;
                priceDiv.classList.remove('loading');
            } catch (error) {
                priceDiv.textContent = `Napaka: ${error.message.slice(0,50)}...`;
                priceDiv.classList.add('error');
            }
            
            // Transactions
            const txData = await fetchRest('/transactions?limit=10');
            const statsData = await fetchRest('/stats');
            const txTable = document.querySelector('#tx-table tbody');
            const txCounter = document.getElementById('tx-counter');
            const txDetails = document.getElementById('tx-details');
            if (txData.error || statsData.error) {
                txCounter.textContent = `Napaka: ${txData.error || statsData.error}`;
                txCounter.classList.add('error');
                txDetails.style.display = 'none';
            } else {
                txCounter.textContent = `${statsData.transactions_today || 'N/A'} (24h)`;
                txCounter.classList.remove('loading');
                txTable.innerHTML = (txData.items || []).map(tx => `
                    <tr>
                        <td>${(tx.hash || '').slice(0,10)}...</td>
                        <td>${(tx.from?.hash || '').slice(0,10)}...</td>
                        <td>${tx.to ? tx.to.hash.slice(0,10)+'...' : 'Contract'}</td>
                        <td>${tx.value ? (Number(BigInt(tx.value) / ATTO)).toFixed(2) + ' FLR' : '0'}</td>
                    </tr>
                `).join('');
                txDetails.style.display = 'block';
            }
            
            // Active Validators
            const validatorsData = await fetchRpc('platform.getCurrentValidators');
            const valTable = document.querySelector('#validators-table tbody');
            const valCounter = document.getElementById('validators-counter');
            if (validatorsData.error) {
                valCounter.textContent = `Napaka: ${validatorsData.error.slice(0,50)}...`;
                valCounter.classList.add('error');
            } else {
                const validators = validatorsData.validators || [];
                valCounter.textContent = `Aktivnih: ${validators.length}`;
                valCounter.classList.remove('loading');
                valTable.innerHTML = validators.slice(0,20).map(val => `
                    <tr>
                        <td>${(val.nodeID || '').slice(0,10)}...</td>
                        <td>${val.stakeAmount ? (Number(BigInt(val.stakeAmount) / ATTO)).toFixed(0) + ' FLR' : 'N/A'}</td>
                        <td>${val.delegatedAmount ? (Number(BigInt(val.delegatedAmount) / ATTO)).toFixed(0) + ' FLR' : '0'}</td>
                        <td>Aktiven</td>
                    </tr>
                `).join('');
            }
            
            // Stake / Delegations
            const totalStakeData = await fetchRpc('platform.getTotalStake');
            const stakeDiv = document.getElementById('stake-info');
            let totalDelegated = 0;
            if (!validatorsData.error && validatorsData.validators) {
                totalDelegated = validatorsData.validators.reduce((sum, val) => 
                    sum + (val.delegatedAmount ? Number(BigInt(val.delegatedAmount) / ATTO) : 0), 0
                );
            }
            if (totalStakeData.error) {
                stakeDiv.innerHTML = `<p>Napaka: ${totalStakeData.error.slice(0,50)}...</p>`;
                stakeDiv.classList.add('error');
            } else {
                const totalStake = totalStakeData.stakeAmount ? Number(BigInt(totalStakeData.stakeAmount) / ATTO) : 0;
                stakeDiv.innerHTML = `
                    <p>Total Stake: ${totalStake.toFixed(0)} FLR</p>
                    <p>Total Delegations: ${totalDelegated.toFixed(0)} FLR</p>
                `;
                stakeDiv.classList.remove('loading');
            }
            
            // Network Activity
            const blocksData = await fetchRest('/blocks?limit=500');
            const activityDiv = document.getElementById('activity-info');
            if (blocksData.error) {
                activityDiv.textContent = `Napaka: ${blocksData.error}`;
                activityDiv.classList.add('error');
            } else {
                const tenDaysAgo = Date.now() - 10 * 24 * 60 * 60 * 1000;
                const recentBlocks = (blocksData.items || []).filter(block => new Date(block.timestamp).getTime() > tenDaysAgo);
                const dailyCounts = recentBlocks.reduce((acc, block) => {
                    const day = new Date(block.timestamp).toLocaleDateString('sl-SI');
                    acc[day] = (acc[day] || 0) + 1;
                    return acc;
                }, {});
                activityDiv.innerHTML = Object.entries(dailyCounts).map(([day, count]) => `<p>${day}: ${count} blokov</p>`).join('') || '<p>Ni aktivnosti v zadnjih 10 dneh</p>';
                activityDiv.classList.remove('loading');
            }
        }
        
        updateDashboard();
        setInterval(updateDashboard, 30000);
    </script>
</body>
</html>
