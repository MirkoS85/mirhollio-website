<!DOCTYPE html>
<html lang="sl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MirSFlr - Flare Network Live Dashboard</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #f4f4f4; color: #333; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { text-align: center; color: #1a73e8; }
        .section { background: white; margin: 20px 0; padding: 20px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); display: flex; flex-wrap: wrap; justify-content: space-between; }
        .counter { font-size: 2em; font-weight: bold; color: #1a73e8; text-align: center; width: 100%; }
        table { width: 48%; border-collapse: collapse; margin-top: 10px; }
        th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; font-size: 0.9em; }
        th { background-color: #f8f9fa; }
        .loading { text-align: center; color: #666; }
        .error { color: #d93025; text-align: center; }
        details { margin-top: 10px; width: 100%; }
        summary { cursor: pointer; font-weight: bold; color: #1a73e8; }
        .activity-text { font-size: 0.9em; color: #666; margin-bottom: 10px; width: 100%; }
        canvas { width: 48%; height: 300px; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>üî• MirSFlr - Flare Network Live Podatki</h1>
        
        <!-- FLR Price -->
        <div class="section">
            <h2>FLR Token Price (EUR)</h2>
            <div id="flr-price" class="counter loading">Nalagam...</div>
        </div>
        
        <!-- Transactions -->
        <div class="section">
            <h2>Transakcije (24h)</h2>
            <div id="tx-counter" class="counter loading">Nalagam...</div>
            <details id="tx-details">
                <summary>Raz≈°iri zadnjih 10 transakcij</summary>
                <table id="tx-table">
                    <thead><tr><th>Hash</th><th>Od</th><th>Do</th><th>Vrednost (FLR)</th></tr></thead>
                    <tbody></tbody>
                </table>
            </details>
        </div>
        
        <!-- Active Validators -->
        <div class="section">
            <h2>Aktivni Validatorji</h2>
            <div id="validators-counter" class="counter loading">Nalagam...</div>
            <table id="validators-table">
                <thead><tr><th>Node ID</th><th>Stake (FLR)</th><th>Delegated (FLR)</th><th>Status</th></tr></thead>
                <tbody></tbody>
            </table>
            <canvas id="validators-chart"></canvas>
        </div>
        
        <!-- Stake / Delegations -->
        <div class="section">
            <h2>Stake & Delegations</h2>
            <div id="stake-info" class="loading">Nalagam...</div>
            <canvas id="stake-chart"></canvas>
        </div>
        
        <!-- Network Activity -->
        <div class="section">
            <h2>Network Activity (zadnjih 10 dni)</h2>
            <div class="activity-text">Pribli≈æek aktivnosti preko ≈°tevila novih blokov na dan ‚Äì ka≈æe network health (veƒç blokov = veƒçja aktivnost). Vir: Flare Explorer API.</div>
            <div id="activity-info" class="loading">Nalagam...</div>
            <canvas id="activity-chart"></canvas>
        </div>
    </div>

    <script>
        const BLOCKSCOUT_BASE = 'https://flare-explorer.flare.network/api/v2';
        const FLARE_RPC = 'https://flare-api.flare.network/ext/bc/P';
        const COINCAP_URL = 'https://api.coincap.io/v2/assets/flare';
        const USD_TO_EUR = 0.92; // Pribli≈æen teƒçaj; za natanƒçnej≈°i dodaj API
        const ATTO = BigInt("1000000000000000000");
        
        let validatorsChart, stakeChart, activityChart;
        
        // Fetch REST
        async function fetchRest(endpoint) {
            try {
                const response = await fetch(`${BLOCKSCOUT_BASE}${endpoint}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                return await response.json();
            } catch (error) {
                console.error('Blockscout Error:', error);
                return { error: error.message };
            }
        }
        
        // Fetch RPC
        async function fetchRpc(method) {
            try {
                const response = await fetch(FLARE_RPC, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: method,
                        params: []
                    })
                });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                if (data.error) throw new Error(data.error.message);
                return data.result;
            } catch (error) {
                console.error('RPC Error:', error);
                return { error: error.message };
            }
        }
        
        // Osve≈æi
        async function updateDashboard() {
            // FLR Price
            const priceDiv = document.getElementById('flr-price');
            try {
                const priceResponse = await fetch(COINCAP_URL);
                if (!priceResponse.ok) throw new Error('CoinCap error');
                const priceData = await priceResponse.json();
                const usdPrice = parseFloat(priceData.data.priceUsd);
                const eurPrice = (usdPrice * USD_TO_EUR).toFixed(4); // Veƒç decimalk
                priceDiv.textContent = `${eurPrice} ‚Ç¨`;
                priceDiv.classList.remove('loading');
            } catch (error) {
                priceDiv.textContent = `Napaka: ${error.message}`;
                priceDiv.classList.add('error');
            }
            
            // Transactions
            const txData = await fetchRest('/transactions?limit=10');
            const statsData = await fetchRest('/stats');
            const txTable = document.querySelector('#tx-table tbody');
            const txCounter = document.getElementById('tx-counter');
            const txDetails = document.getElementById('tx-details');
            if (txData.error || statsData.error) {
                txCounter.textContent = `Napaka: ${txData.error || statsData.error}`;
                txCounter.classList.add('error');
                txDetails.style.display = 'none';
            } else {
                txCounter.textContent = `${statsData.transactions_today || 'N/A'} (24h)`;
                txCounter.classList.remove('loading');
                txTable.innerHTML = (txData.items || []).map(tx => `
                    <tr>
                        <td>${(tx.hash || '').slice(0,10)}...</td>
                        <td>${(tx.from?.hash || '').slice(0,10)}...</td>
                        <td>${tx.to ? tx.to.hash.slice(0,10)+'...' : 'Contract'}</td>
                        <td>${tx.value ? (Number(BigInt(tx.value) / ATTO)).toFixed(4) + ' FLR' : '0'}</td> <!-- Veƒç decimalk -->
                    </tr>
                `).join('');
                txDetails.style.display = 'block';
            }
            
            // Active Validators
            const validatorsData = await fetchRpc('platform.getCurrentValidators');
            const valTable = document.querySelector('#validators-table tbody');
            const valCounter = document.getElementById('validators-counter');
            const valChartCtx = document.getElementById('validators-chart').getContext('2d');
            if (validatorsData.error) {
                valCounter.textContent = `Napaka: ${validatorsData.error}`;
                valCounter.classList.add('error');
            } else {
                const validators = validatorsData.validators || [];
                valCounter.textContent = `Aktivnih: ${validators.length}`;
                valCounter.classList.remove('loading');
                valTable.innerHTML = validators.slice(0,10).map(val => ` <!-- Samo top 10 za prostor -->
                    <tr>
                        <td>${(val.nodeID || '').slice(0,10)}...</td>
                        <td>${val.stakeAmount ? (Number(BigInt(val.stakeAmount) / ATTO)).toFixed(4) + ' FLR' : 'N/A'}</td> <!-- Veƒç decimalk -->
                        <td>${val.delegatedAmount ? (Number(BigInt(val.delegatedAmount) / ATTO)).toFixed(4) + ' FLR' : '0'}</td>
                        <td>Aktiven</td>
                    </tr>
                `).join('');
                
                // Graf za validators (bar za top 5 stake)
                const sortedVal = validators.sort((a,b) => Number(BigInt(b.stakeAmount || 0)) - Number(BigInt(a.stakeAmount || 0))).slice(0,5);
                if (validatorsChart) validatorsChart.destroy();
                validatorsChart = new Chart(valChartCtx, {
                    type: 'bar',
                    data: {
                        labels: sortedVal.map(v => v.nodeID.slice(0,6)+'...'),
                        datasets: [{ label: 'Stake (FLR)', data: sortedVal.map(v => Number(BigInt(v.stakeAmount) / ATTO).toFixed(4)) }]
                    },
                    options: { responsive: true, scales: { y: { beginAtZero: true } } }
                });
            }
            
            // Stake / Delegations
            const totalStakeData = await fetchRpc('platform.getTotalStake');
            const stakeDiv = document.getElementById('stake-info');
            const stakeChartCtx = document.getElementById('stake-chart').getContext('2d');
            let totalDelegated = 0;
            if (!validatorsData.error && validatorsData.validators) {
                totalDelegated = validatorsData.validators.reduce((sum, val) => 
                    sum + (val.delegatedAmount ? Number(BigInt(val.delegatedAmount) / ATTO) : 0), 0
                );
            }
            if (totalStakeData.error) {
                stakeDiv.innerHTML = `<p>Napaka: ${totalStakeData.error}</p>`;
                stakeDiv.classList.add('error');
            } else {
                const totalStake = totalStakeData.stakeAmount ? Number(BigInt(totalStakeData.stakeAmount) / ATTO) : 0;
                stakeDiv.innerHTML = `
                    <p>Total Stake: ${totalStake.toFixed(4)} FLR</p>
                    <p>Total Delegations: ${totalDelegated.toFixed(4)} FLR</p>
                `;
                stakeDiv.classList.remove('loading');
                
                // Pie graf za stake vs delegations
                if (stakeChart) stakeChart.destroy();
                stakeChart = new Chart(stakeChartCtx, {
                    type: 'pie',
                    data: {
                        labels: ['Total Stake', 'Total Delegations'],
                        datasets: [{ data: [totalStake.toFixed(4), totalDelegated.toFixed(4)], backgroundColor: ['#1a73e8', '#0f9d58'] }]
                    },
                    options: { responsive: true }
                });
            }
            
            // Network Activity
            const blocksData = await fetchRest('/blocks?limit=500');
            const activityDiv = document.getElementById('activity-info');
            const activityChartCtx = document.getElementById('activity-chart').getContext('2d');
            if (blocksData.error) {
                activityDiv.textContent = `Napaka: ${blocksData.error}`;
                activityDiv.classList.add('error');
            } else {
                const tenDaysAgo = Date.now() - 10 * 24 * 60 * 60 * 1000;
                const recentBlocks = (blocksData.items || []).filter(block => new Date(block.timestamp).getTime() > tenDaysAgo);
                const dailyCounts = recentBlocks.reduce((acc, block) => {
                    const day = new Date(block.timestamp).toLocaleDateString('sl-SI');
                    acc[day] = (acc[day] || 0) + 1;
                    return acc;
                }, {});
                activityDiv.innerHTML = Object.entries(dailyCounts).map(([day, count]) => `<p>${day}: ${count} blokov</p>`).join('') || '<p>Ni aktivnosti</p>';
                activityDiv.classList.remove('loading');
                
                // Line graf za dnevno aktivnost
                const days = Object.keys(dailyCounts).sort();
                if (activityChart) activityChart.destroy();
                activityChart = new Chart(activityChartCtx, {
                    type: 'line',
                    data: {
                        labels: days,
                        datasets: [{ label: 'Bloki na dan', data: days.map(d => dailyCounts[d]), borderColor: '#1a73e8' }]
                    },
                    options: { responsive: true, scales: { y: { beginAtZero: true } } }
                });
            }
        }
        
        updateDashboard();
        setInterval(updateDashboard, 30000);
    </script>
</body>
</html>
